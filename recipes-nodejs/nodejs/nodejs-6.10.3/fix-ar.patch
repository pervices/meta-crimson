diff --git a/meta-oe/recipes-devtools/nodejs/nodejs/fix_ar.patch b/meta-oe/recipes-devtools/nodejs/nodejs/fix_ar.patch
new file mode 100644
index 0000000..871ad8d
--- /dev/null
+++ b/meta-oe/recipes-devtools/nodejs/nodejs/fix_ar.patch
@@ -0,0 +1,86 @@
+nodejs build failure due to execvp arg list too long
+    
+In builds with really long paths, we'll see the error message
+"execvp: printf: Argument list too long" when the system is trying
+to generate ar files.
+
+Modify the way args are passed to ar to avoid this restriction.
+		        
+Signed-off-by: Amy Fong <amy.fong@windriver.com>
+---
+ deps/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/make.py |   20 +++++++++-
+ tools/gyp/pylib/gyp/generator/make.py                          |   20 +++++++++-
+ 2 files changed, 36 insertions(+), 4 deletions(-)
+
+--- a/deps/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/make.py
++++ b/deps/npm/node_modules/node-gyp/gyp/pylib/gyp/generator/make.py
+@@ -136,6 +136,23 @@
+ quiet_cmd_link = LINK($(TOOLSET)) $@
+ cmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)
+ 
++define xargs
++$(1) $(wordlist 1,1000,$(2))
++$(if $(word 1001,$(2)),$(call xargs,$(1),$(wordlist 1001,$(words $(2)),$(2))))
++endef
++
++define write-to-file
++@: >$(1)
++$(call xargs,@printf "%s\\n" >>$(1),$(2))
++endef
++
++OBJ_FILE_LIST := ar-file-list
++
++create_archive = \\
++        rm -f $(1) $(OBJ_FILE_LIST); mkdir -p `dirname $(1)` \\
++        $(call write-to-file,$(OBJ_FILE_LIST),$(filter %.o,$(2))) \\
++        $(AR.$(TOOLSET)) $(ARFLAGS.$(TOOLSET)) $(1) @$(OBJ_FILE_LIST)
++
+ # We support two kinds of shared objects (.so):
+ # 1) shared_library, which is just bundling together many dependent libraries
+ # into a link line.
+@@ -1546,8 +1563,7 @@
+         self.WriteDoCmd([self.output_binary], link_deps, 'alink_thin',
+                         part_of_all, postbuilds=postbuilds)
+       else:
+-        self.WriteDoCmd([self.output_binary], link_deps, 'alink', part_of_all,
+-                        postbuilds=postbuilds)
++        self.WriteMakeRule([self.output_binary], link_deps, actions = ['$(call create_archive,$@,$^)'])
+     elif self.type == 'shared_library':
+       self.WriteLn('%s: LD_INPUTS := %s' % (
+             QuoteSpaces(self.output_binary),
+--- a/tools/gyp/pylib/gyp/generator/make.py
++++ b/tools/gyp/pylib/gyp/generator/make.py
+@@ -133,6 +133,23 @@
+ quiet_cmd_link = LINK($(TOOLSET)) $@
+ cmd_link = $(LINK.$(TOOLSET)) $(GYP_LDFLAGS) $(LDFLAGS.$(TOOLSET)) -o $@ -Wl,--start-group $(LD_INPUTS) -Wl,--end-group $(LIBS)
+ 
++define xargs
++$(1) $(wordlist 1,1000,$(2))
++$(if $(word 1001,$(2)),$(call xargs,$(1),$(wordlist 1001,$(words $(2)),$(2))))
++endef
++
++define write-to-file
++@: >$(1)
++$(call xargs,@printf "%s\\n" >>$(1),$(2))
++endef
++
++OBJ_FILE_LIST := ar-file-list
++
++create_archive = \\
++        rm -f $(1) $(OBJ_FILE_LIST); mkdir -p `dirname $(1)` \\
++        $(call write-to-file,$(OBJ_FILE_LIST),$(filter %.o,$(2))) \\
++        $(AR.$(TOOLSET)) $(ARFLAGS.$(TOOLSET)) $(1) @$(OBJ_FILE_LIST)
++
+ # We support two kinds of shared objects (.so):
+ # 1) shared_library, which is just bundling together many dependent libraries
+ # into a link line.
+@@ -1517,8 +1534,7 @@
+       for link_dep in link_deps:
+         assert ' ' not in link_dep, (
+             "Spaces in alink input filenames not supported (%s)"  % link_dep)
+-      self.WriteDoCmd([self.output_binary], link_deps, 'alink', part_of_all,
+-                      postbuilds=postbuilds)
++      self.WriteMakeRule([self.output_binary], link_deps, actions = ['$(call create_archive,$@,$^)'])
+     elif self.type == 'shared_library':
+       self.WriteLn('%s: LD_INPUTS := %s' % (
+             QuoteSpaces(self.output_binary),
